#!/bin/bash

# Configuration
CONFIG_DIR="$HOME/.config/simple-pki"
CONFIG_FILE="$CONFIG_DIR/config.json"
AUTHORIZED_KEYS="$HOME/.ssh/authorized_keys"
BACKUP_KEYS="$HOME/.ssh/authorized_keys.simple-pki-backup"
VERSION="1.0.0"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Check dependencies
command -v curl >/dev/null 2>&1 || { echo -e "${RED}Error: curl is required but not installed.${NC}" >&2; exit 1; }
command -v jq >/dev/null 2>&1 || { echo -e "${RED}Error: jq is required but not installed.${NC}" >&2; exit 1; }

usage() {
    echo "Usage: simple-pki [OPTIONS]"
    echo "Options:"
    echo "  -u USERNAME(S)  GitHub username(s) to configure (comma separated or multiple -u flags)"
    echo "  -d              Daemon mode (non-interactive update from config)"
    echo "  -h              Show this help message"
}

init_config() {
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
    fi
}

get_gh_user() {
    local username=$1
    local response
    response=$(curl -s "https://api.github.com/users/$username")
    
    if echo "$response" | grep -q "\"message\": \"Not Found\""; then
        return 1
    fi
    echo "$response"
}

get_gh_keys() {
    local username=$1
    curl -s "https://github.com/$username.keys"
}

setup_cron() {
    local cron_schedule=${1:-"* * * * *"} # Default every minute
    local script_path
    script_path=$(realpath "$0")
    
    # Check if cron is already set up
    if crontab -l 2>/dev/null | grep -q "$script_path -d"; then
        echo "Cron job already exists."
        return
    fi

    (crontab -l 2>/dev/null; echo "$cron_schedule $script_path -d >> $HOME/.simple-pki.log 2>&1") | crontab -
    echo -e "${GREEN}Cron job added.${NC}"
}

update_keys() {
    local usernames=("${@}")
    local all_keys=""
    
    for user in "${usernames[@]}"; do
        echo "Fetching keys for $user..."
        keys=$(get_gh_keys "$user")
        if [ -n "$keys" ]; then
            all_keys+="# Keys for $user (managed by simple-pki)\n$keys\n"
        else
            echo -e "${YELLOW}Warning: No keys found for $user${NC}"
        fi
    done

    if [ -z "$all_keys" ]; then
        echo -e "${RED}No keys retrieved. Aborting update.${NC}"
        exit 1
    fi

    # Backup logic
    if [ -f "$AUTHORIZED_KEYS" ]; then
        if [ ! -f "$BACKUP_KEYS" ]; then
             cp "$AUTHORIZED_KEYS" "$BACKUP_KEYS"
             echo "Backup created at $BACKUP_KEYS"
        fi
    else
        mkdir -p "$HOME/.ssh"
        touch "$AUTHORIZED_KEYS"
    fi

    echo -e "$all_keys" > "$AUTHORIZED_KEYS"
    chmod 600 "$AUTHORIZED_KEYS"
    echo -e "${GREEN}Authorized keys updated successfully.${NC}"
}

save_config() {
    local usernames=("${@}")
    local json_array
    json_array=$(printf '%s\n' "${usernames[@]}" | jq -R . | jq -s .)
    
    cat > "$CONFIG_FILE" <<EOF
{
  "version": "$VERSION",
  "usernames": $json_array
}
EOF
}

# Daemon Mode
if [ "$1" == "-d" ]; then
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "Config not found. Run interactively first."
        exit 1
    fi
    
    usernames_json=$(jq -r '.usernames[]' "$CONFIG_FILE")
    usernames=()
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            usernames+=("$line")
        fi
    done <<< "$usernames_json"
    
    update_keys "${usernames[@]}"
    exit 0
fi

# Interactive Mode
USERNAMES=()

while getopts "u:h" opt; do
    case $opt in
        u) IFS=',' read -ra ADDR <<< "$OPTARG"; USERNAMES+=("${ADDR[@]}") ;;
        h) usage; exit 0 ;;
        *) usage; exit 1 ;;
    esac
done

if [ ${#USERNAMES[@]} -eq 0 ]; then
    # If config exists, maybe we just want to re-run or update? 
    # But instructions say "check for config... if not found... take args".
    # Assuming if config exists and no args, we might just update? 
    # But let's stick to requirements: if not found, require args.
    if [ -f "$CONFIG_FILE" ]; then
        echo "Configuration found. Updating keys..."
        usernames_json=$(jq -r '.usernames[]' "$CONFIG_FILE")
        USERNAMES=()
        while IFS= read -r line; do
            if [ -n "$line" ]; then
                USERNAMES+=("$line")
            fi
        done <<< "$usernames_json"
    else
        echo -e "${RED}No configuration found. Please provide usernames with -u.${NC}"
        usage
        exit 1
    fi
else
    # Verify Users
    VALID_USERS=()
    for user in "${USERNAMES[@]}"; do
        echo "Checking user: $user..."
        metadata=$(get_gh_user "$user")
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}User found:${NC}"
            echo "$metadata" | jq '{login, name, id, public_repos, bio}'
            read -p "Is this correct? [Y/n] " confirm
            confirm=${confirm:-Y}
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                VALID_USERS+=("$user")
            else
                echo "Skipping $user"
            fi
        else
            echo -e "${RED}User $user not found on GitHub.${NC}"
        fi
    done
    USERNAMES=("${VALID_USERS[@]}")
fi

if [ ${#USERNAMES[@]} -eq 0 ]; then
    echo "No valid users selected. Exiting."
    exit 1
fi

# Confirmation to overwrite
echo -e "${YELLOW}This will overwrite $AUTHORIZED_KEYS with keys from: ${USERNAMES[*]}${NC}"
read -p "Do you want to continue? [Y/n] " confirm
confirm=${confirm:-Y}
if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 0
fi

init_config
save_config "${USERNAMES[@]}"
update_keys "${USERNAMES[@]}"

# Cron Setup
read -p "Do you want to set up a cron job to auto-update keys? [Y/n] " cron_confirm
cron_confirm=${cron_confirm:-Y}
if [[ "$cron_confirm" =~ ^[Yy]$ ]]; then
    read -p "Enter cron schedule (default: '* * * * *' [every minute]): " schedule
    setup_cron "${schedule}"
fi

